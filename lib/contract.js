/**
 * Smart Contract Interaction Library
 * 
 * Provides ethers.js wrappers for interacting with the SkillCredential contract.
 * Includes demo mode fallback for when RPC is unavailable.
 */

import { ethers } from 'ethers';
import { isDemoMode, generateMockTxHash, generateMockTokenId, generateMockIPFSUri, simulateDelay } from './demo';

// Contract ABI (only the functions we need)
const SKILL_CREDENTIAL_ABI = [
    'function mintCredential(address to, string calldata skill, string calldata metadataURI) external returns (uint256)',
    'function tokenURI(uint256 tokenId) public view returns (string memory)',
    'function skillName(uint256 tokenId) public view returns (string memory)',
    'function issuedAt(uint256 tokenId) public view returns (uint256)',
    'function ownerOf(uint256 tokenId) public view returns (address)',
    'function balanceOf(address owner) public view returns (uint256)',
    'function nextTokenId() public view returns (uint256)',
    'event SkillIssued(address indexed to, uint256 indexed tokenId, string skill, string metadataURI)'
];

// Get deployed contract address
function getContractAddress() {
    // First check environment variable
    if (process.env.NEXT_PUBLIC_CONTRACT_ADDRESS) {
        return process.env.NEXT_PUBLIC_CONTRACT_ADDRESS;
    }

    // Try to read from deployed.json (would be generated by deploy script)
    try {
        // In production, this would be imported or fetched
        return '0xDEMO_CONTRACT_SKILLCHAIN_CREDENTIAL';
    } catch {
        return null;
    }
}

// Get RPC URL
function getRpcUrl() {
    return process.env.RPC_URL || process.env.NEXT_PUBLIC_RPC_URL || null;
}

// Get signer private key (server-side only, for minting)
function getPrivateKey() {
    return process.env.PRIVATE_KEY || null;
}

/**
 * Get a provider instance
 */
export function getProvider() {
    const rpcUrl = getRpcUrl();
    if (!rpcUrl) {
        console.warn('No RPC URL configured, using demo mode');
        return null;
    }

    try {
        return new ethers.providers.JsonRpcProvider(rpcUrl);
    } catch (error) {
        console.error('Failed to create provider:', error);
        return null;
    }
}

/**
 * Get a signer instance (for server-side minting)
 */
export function getSigner() {
    const provider = getProvider();
    const privateKey = getPrivateKey();

    if (!provider || !privateKey) {
        return null;
    }

    try {
        return new ethers.Wallet(privateKey, provider);
    } catch (error) {
        console.error('Failed to create signer:', error);
        return null;
    }
}

/**
 * Get contract instance
 */
export function getContract(signerOrProvider) {
    const contractAddress = getContractAddress();

    if (!contractAddress || !signerOrProvider) {
        return null;
    }

    try {
        return new ethers.Contract(contractAddress, SKILL_CREDENTIAL_ABI, signerOrProvider);
    } catch (error) {
        console.error('Failed to create contract instance:', error);
        return null;
    }
}

/**
 * Mint a skill credential NFT
 * 
 * @param {string} toAddress - Recipient wallet address
 * @param {string} skillId - Skill identifier
 * @param {string} skillTitle - Human-readable skill name
 * @param {Object} metadata - NFT metadata object
 * @returns {Object} Mint result with tokenId, txHash, metadataURI
 */
export async function mintCredential(toAddress, skillId, skillTitle, metadata) {
    // Check demo mode
    if (isDemoMode()) {
        console.log('Demo mode: simulating mint transaction');
        await simulateDelay(2000);

        return {
            success: true,
            tokenId: generateMockTokenId(),
            txHash: generateMockTxHash(),
            metadataURI: generateMockIPFSUri(skillId),
            demoMode: true
        };
    }

    // Production mode: interact with real contract
    const signer = getSigner();
    if (!signer) {
        throw new Error('No signer available. Configure PRIVATE_KEY and RPC_URL or enable demo mode.');
    }

    const contract = getContract(signer);
    if (!contract) {
        throw new Error('Failed to initialize contract. Check CONTRACT_ADDRESS configuration.');
    }

    try {
        // In production, you'd upload metadata to IPFS here
        // For now, we'll use a mock URI
        const metadataURI = generateMockIPFSUri(skillId);

        // Call mint function
        const tx = await contract.mintCredential(toAddress, skillTitle, metadataURI);
        console.log('Transaction sent:', tx.hash);

        // Wait for confirmation
        const receipt = await tx.wait();
        console.log('Transaction confirmed:', receipt.transactionHash);

        // Get tokenId from event
        const event = receipt.events?.find(e => e.event === 'SkillIssued');
        const tokenId = event?.args?.tokenId?.toNumber() || 0;

        return {
            success: true,
            tokenId,
            txHash: receipt.transactionHash,
            metadataURI,
            demoMode: false
        };
    } catch (error) {
        console.error('Mint transaction failed:', error);
        throw new Error(`Minting failed: ${error.message}`);
    }
}

/**
 * Get credentials for an address
 * 
 * @param {string} address - Wallet address to check
 * @returns {Array} List of credentials owned by the address
 */
export async function getCredentialsForAddress(address) {
    // Demo mode: return from issued.json
    if (isDemoMode()) {
        try {
            const issued = await import('../data/issued.json');
            return issued.credentials.filter(c =>
                c.wallet.toLowerCase() === address.toLowerCase()
            );
        } catch {
            return [];
        }
    }

    // Production mode: query contract events
    const provider = getProvider();
    if (!provider) {
        // Fallback to issued.json
        try {
            const issued = await import('../data/issued.json');
            return issued.credentials.filter(c =>
                c.wallet.toLowerCase() === address.toLowerCase()
            );
        } catch {
            return [];
        }
    }

    const contract = getContract(provider);
    if (!contract) {
        return [];
    }

    try {
        // Query SkillIssued events for this address
        const filter = contract.filters.SkillIssued(address);
        const events = await contract.queryFilter(filter);

        const credentials = await Promise.all(events.map(async (event) => {
            const tokenId = event.args.tokenId.toNumber();
            const skillTitle = event.args.skill;
            const metadataURI = event.args.metadataURI;
            const issuedAt = await contract.issuedAt(tokenId);

            return {
                tokenId,
                wallet: address,
                skillTitle,
                metadataURI,
                txHash: event.transactionHash,
                issuedAt: new Date(issuedAt.toNumber() * 1000).toISOString()
            };
        }));

        return credentials;
    } catch (error) {
        console.error('Failed to fetch credentials:', error);
        return [];
    }
}

export default {
    getProvider,
    getSigner,
    getContract,
    mintCredential,
    getCredentialsForAddress
};
